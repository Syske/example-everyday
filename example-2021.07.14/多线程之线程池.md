# 多线程之线程池

### 前言

最近一段时间，我们一直都在分享多线程相关知识，也一直有用线程池，但是一直没有介绍线程池相关知识，所以今天我们就先来看下线程池相关的知识点。

### 线程池

`ThreadPool`，线程池，顾名思义就是存放线程的池子，也是`jdk1.5`引入的。对我们而言，它的最主要优势就是简化了线程启动流程，让我们可以更方便地使用多线程，再也不用手动`start`线程，直接通过线程池提交我们的任务即可，而且合理使用线程池至于可以带来以下几个好处：

- 降低资源消耗：复用线程，降低创建和销毁线程带来的资源消耗

- 提高响应速度：使用线程池，省去了线程创建和初始化过程，所以任务可以更快执行

- 提高线程的可管理性：可以直接通过线程池管理、监控、调度线程，线程管理更方便

  

#### 常用线程池

常用的线程池有`SingleThreadExecutor`、`CachedThreadPool`、`ScheduledThreadPool`、`FixedThreadPool`，他们分别是单线程调度器，缓存线程池，定时任务线程池和固定线程池，他们都可以通过`Executors`创建，调用对应的静态方法即可，由于这一块的内容比较多，所以今天就简单提一下，后面专门讲一次。

![](https://gitee.com/sysker/picBed/raw/master/20210714085130.png)

#### 自定义线程池

我们今天着重讲下自定义线程池，自定义线程池也很简单，直接`new ThreadPoolExecutor() `，然后传入对应的参数即可，大家可以看下下面的示例：

```java
int corePoolSize = 10;
int maximumPoolSize = 20;
long keepAliveTime = 1000;
TimeUnit unit = TimeUnit.MICROSECONDS;
BlockingDeque<Runnable> workQueue = new LinkedBlockingDeque<>();
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
for (int i = 0; i < 50; i++) {
    threadPoolExecutor.execute(() -> {
        String name = Thread.currentThread().getName();
        System.out.println("hello threadPool: "+ name);
    });
}
threadPoolExecutor.shutdown();
```

`ThreadPoolExecutor`有三个构造方法，至少需要三个参数

![](https://gitee.com/sysker/picBed/raw/master/20210714085458.png)

